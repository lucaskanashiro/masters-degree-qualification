\chapter{Teste de Desempenho em Larga Escala para Cidades Inteligentes}
\label{cap:geracao_de_cenarios_de_teste}

Como apresentado na Seção \ref{sec:analise_performance}, simulação é uma das
técnicas de avaliação utilizada em análises de desempenho.  Neste trabalho
defendemos que simuladores de Cidades Inteligentes são ferramentas capazes de
gerar cargas realistas para a realização de testes de desempenho em sistemas e
aplicações para tal contexto. Cenários complexos advindos de simuladores, onde
picos de cargas e eventos inesperados podem ser comtemplados, podem facilitar
tal tarefa.

Testes de desempenho devem ser incorporados no ciclo desenvolvimento de
sistemas e aplicações de Cidades Inteligentes, já que queremos que esses
serviços tenham alta disponibilidade.  Entretanto, cidades estão inseridas em
contextos dinâmicos e imprevisíveis, e gerar cargas que se assemelham ao que
acontece no dia-a-dia é uma tarefa complexa. Como simuladores possuem modelos
que visam representar a realidade, inclusive picos e acotecimentos inesperados,
eles se apresentam como uma solução. Com os dados de tais simulações espera-se
realizar testes de carga, e que seja possível a identificaçõe de gargalos nos
sistemas o mais cedo possível no ciclo de desenvolvimento, reduzindo o custo
para correção e garantindo que os usuários terão uma boa experiência utilizando
o serviço quando estiver disponível. Dependendo da implementação e implantação
do sistema, esses testes de carga podem se tornar de estresse podendo levar a
problemas como indisponibilidade do sistema, nesse caso tal sistema não
suportaria a carga gerada pela cidade em questão, necessitando de uma
refatoração visando escalabilidade.

Para realizar testes de desempenho em sistemas e aplicações em Cidades
Inteligentes simuladores devem ser capazes de simular dispositivos de
Internet das Coisas (\textit{IoT}) que monitorem e atuem no contexto da cidade;
possuir modelos que representam o ambiente urbano de maneira realista,
representando toda a dinâmica e peculiaridades da cidade; gerar massa de dados
na escala da cidade; e conseguir se comunicar com os sistemas usando os seus
respectivos protocolos. Com isso, o simulador será capaz de gerar a carga
necessária para realização dos testes. Simuladores já vêm sendo usados para
teste de cenários complexos em outras áreas de pesquisa \cite{mclaren_1992}
\cite{mccown_1996} \cite{dominguez_08} \cite{walker_1998}.

Como prova de conceito da utilização de simuladores na realização de testes de
desempenho em sistemas e aplicações de Cidades Inteligentes, foi realizada uma
integração inicial entre a plataforma InterSCity e o simulador
InterSCSimulator. Nessa integração foi tratado um cenário específico, onde são
simulados carros realizando viagens pela cidade e ao final de cada viagem o
agente tenta encontrar uma vaga de estacionamento disponível mais próxima para
estacionar.

No decorrer deste capítulo serão apresentados I) a implementação desse novo
cenário de simulação, contendo movimentação de carros pela cidade e procura de
vagas de estacionamento e II) a integração preliminar do simulador e da
plataforma. Sendo assim possível realizar testes de desempenho na plataforma
através do simulador.

\section{Simulação de Múltiplos Domínios}
\label{sec:simulation}

O InterSCSimulator é um simulador \textit{Open-Source} e escalável para Cidades
Inteligentes que tem como objetivo simular vários cenários complexos de larga
escala \cite{santana_17}. Até o início deste trabalho apenas cenários de
mobilidade eram suportados, ou seja, eram simuladas viagens de pessoas na
cidade andando, de carro, ônibus e metrô. Durante o início desta pesquisa foi
implementado um novo cenário que contempla a busca de vagas de estacionamento
por carros ao final das suas viagens.

Como entrada da simulação são passados o grafo representando a infraestrutura
rodoviária da cidade, onde as arestas representam ruas e os nós esquinas entre
duas ou mais ruas; e a configuração das viagens, especificando a origem e
destino de cada agente da simulação e o modo de viagem, sendo todos carros.
Para incrementar vagas de estacionamento à simulação foi adicionada uma nova
entrada onde é listado todo o conjunto de vagas da cidade, indicando em que nó
do grafo da cidade cada vaga de estacionamento se encontra; bem como foi
adicionado a cada uma das viagens em qual vaga irá estacionar o agente ao
chegar no término da viagem, considerando que o agente conhece previamente a
vaga de estacionamento que utilizará.

Durante a simulação, cada agente é criado e realiza o seu percurso normalmente,
saindo do seu destino até a sua origem. Ao chegar próximo do seu destino o
simulador recalcula a sua rota para chegar na vaga de estacionamento
previamente especificada. A seguir é apresentado todo o ciclo de simulação de
um agente nesse cenário:

\begin{enumerate}
	\item Agente é criado
	\item O caminho mais curto entre a origem e o destino é calculado
	\item Parte da sua origem no tempo determinado
	\item Ao chegar no nó anterior ao seu destino, a rota é recalculada em
	direção a vaga de estacionamento
	\item Agente estaciona na vaga de estacionamento previamente determinada
\end{enumerate}

Um esquema simples foi implementado para a liberação das vagas de
estacionamento, onde após um tempo fixo depois da ocupação a mesma é liberada,
na implementação atual, a configuração de tempo é de 10 minutos. Esse é um dos
pontos passíveis de melhoria no decorrer do trabalho, onde é necessário
encontrar modelos que representem melhor a realidade.

A partir dessa implementação foi possível realizar simulações contemplando
tanto a questão de mobilidade em uma cidade quanto o estacionamento de carros
ao final de suas viagens. Uma das dificuldades para realizar a simulação desse
novo cenário é a necessidade de saber previamente onde cada agente que
representa um carro irá estacionar. Isso porque mais de um agente não pode ter
como destino a mesma vaga de estacionamento enquanto outro a estiver ocupando,
o que leva a uma complexidade maior na geração dos arquivos de entrada. Esse
problema foi solucionado com a integração do simulador com a plataforma
InterSCity que será apresentada na próxima seção.


\section{Integração entre InterSCSimulator e InterSCity}
\label{sec:integration}

A integração inicial entre o simulador InterSCSimulator e a plataforma
InterSCity foi feita com o intuito de gerar uma carga realista para a
realização de testes de desempenho na plataforma. Bem como foi apresentado no
início deste capítulo, existem alguns requisitos que devem ser implementados
para que seja possível a realização de testes de desempenho na plataforma
InterSCity usando o simulador InterSCSimulator, sendo eles:

\begin{itemize}
	\item Simular dispositivos de Internet das Coisas
	\item Gerar massa de dados na escala de uma cidade
	\item Comunicar via protocolos já utilizados pela plataforma
\end{itemize}

Como apresentado na Seção \ref{sec:interscity}, a plataforma InterSCity
trabalha com os conceitos de recursos da cidade e suas respectivas capacidades
de sensoriamento ou atuação. Além disso, utiliza-se de dois tipos diferentes de
comunicação: síncrona, através de API \textit{Restful}; e assíncrona, através do
protocolo AMQP.

No cenário apresentado na seção anterior, as vagas de estacionamento seriam
recursos da cidade monitorados por algum tipo de dispositivo de Internet das
Coisas. Tais dispositivos seriam capazer de monitorar o estado da vaga, podendo
ser ocupada ou livre. Durante a simulação o estado desses recursos seriam
atualizados sempre que necessário, ou seja, no momento em que um carro
estacionasse ou saísse da vaga de estacionamento.

A integração consistiu na utilização do microserviço \textit{Resource
Discovery} para encontrar a vaga de estacionamento mais próxima do destino da
viagem de cada carro, assim como a atualização do estado da vaga. Para a
utilização do serviço de descoberta provido pelo \textit{Resource Discovery}
foi usada a sua API \textit{Restful}, e o \textit{RabbitMQ} (uma implementação
do protocolo AMQP) foi usado para a atualização do estado das vagas. O ponto
interessante dessa integração é que exercemos carga na plataforma tanto como
uma aplicação que utiliza os serviços providos, como dispositos de Internet das
Coisas que desejam atualizar o estado de recursos da cidade. As Figuras
\ref{fig:descoberta} e \ref{fig:atualizacao} serão utilizadas para detalhar
essa integração de duas vias.

A Figura \ref{fig:descoberta} apresenta a integração realizada para utilização
do serviço de descoberta provido pela plataforma InterSCity.  Para isso foi
utilizado um agente externo chamado \textit{Parking Spot Discoverer}, que fez o
papel de um \textit{middleware} entre os dois sistemas. O uso desse
\textit{middleware} se fez necessário para que a simulação exerça a carga que
aplicações exerceriam utilizando o protocolo \textit{HTTP} para acessara a API
\textit{Restful}. Como requisições \textit{HTTP} são síncronas, a realização
das mesmas dentro da simulação atrasaria consideravelmente a sua finalização,
já que bloquearia a execução dos agentes enquanto aguardariam a resposta da
plataforma. Antes de chegarmos a tal solução implementamos uma versão onde o
próprio simulador fazia requisições \textit{HTTP} para a plataforma em tempo de
simulação, entretanto, essa solução gerou um gargalo na simulação.  Abaixo será
descrito o fluxo de atividades apresentado na Figura \ref{fig:descoberta}.

\begin{enumerate}
	\item Ao chegar um nó antes do seu destino, o carro solicita a vaga de
	estacionamento para o \textit{Parking Controller}, passando a sua
	localização como parâmetro.

	\item O \textit{Parking Controller} então envia a localização para o
	\textit{Parking Spot Discoverer} e solicita a vaga disponível mais próxima,
	em um raio de 500 metros.

	\item O \textit{Parking Spot Discoverer} faz uma requisição \textit{HTTP}
	para o serviço de descoberta da plataforma e ele retorna a vaga em questão.
	Caso não seja encontrada uma vaga disponível em um raio de 500 metros, esse
	raio é multiplicado por dois até que se encontre uma vaga disponível.

	\item O identificador da vaga é retornado para o \textit{Parking
	Controller} e ele marca a vaga como utilizada em uma estrutura
	de dados mantida no simulador.

	\item O identificador da vaga é recebido pelo agente que representa o carro
	e a rota é recalcula para chegar até ela.
\end{enumerate}

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.5\textwidth]{figures/integration_get_data.png}
	\caption{Integração para descoberta de vagas livres próximo do destino da
	viagem}
	\label{fig:descoberta}
\end{figure}

A Figura \ref{fig:atualizacao} apresenta a integração realizada com o intuito
de atualizar o estado das vagas de estacionamento na plataforma baseado nos
acontecimentos da simulação. Foi adicionado no simulador a funcionalidade de
publicação dos eventos da simulação via protocolo \textit{AMQP} para os
interessados, com isso não foi necesário a utilização de um agente externo, já
que a plataforma também utiliza o mesmo protocolo para divulgação dos seus
dados entre microserviços. A seguir será apresentado mais detalhadamente esse
fluxo.

\begin{enumerate}
	\item O agente carro estaciona na vaga de estacionamento e notifica o
	\textit{Parking Controller}.

	\item O \textit{Parking Controller} publica, via \textit{RabbitMQ}, que a
	vaga está ocupada usando o seu identificador.

	\item O \textit{RabbitMQ} repassa esse dado par os microserviços
	\textit{Resource Catalog} e \textit{Data Collector}, entretanto esse dado
	só é utilizado pelo \textit{Data Collector}.
\end{enumerate}

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.5\textwidth]{figures/integration_publish_data.png}
	\caption{Integração para publicar dados}
	\label{fig:atualizacao}
\end{figure}

Vale ressaltar que esse mesmo fluxo apresentado na Figura \ref{fig:atualizacao}
é executado quando a vaga é ocupada, entre os passos 4 e 5 da Figura
\ref{fig:descoberta}. Com isso, a plataforma atualiza os dados da vaga tanto
quando a mesma é ocupada quanto liberada.

Uma das limitações apresentadas é que todas as vagas de estacionamento devem
ser criadas previamente na plataforma para que as integrações apresentadas
funcionem como o esperado, sendo esse mais um ponto para evolução no decorrer
do trabalho.

\section{Resultados Preliminares}
\label{sec:resultados}

Como o objetivo de validar a simulação e a integração apresentadas nas seções
anteriores foi executada uma simulação de um cenário envolvendo a cidade de São
Paulo para a realização de testes de desempenho da plataforma InterSCity.
Foram utilizados dados da pesquisa de origem destino realizado pela Companhia
de Metrô de São Paulo em 2007 para a geração das viagens de carro e as vagas
de estacionamento oriundas dos dados de Zona Azul e do \textit{Open Street
Maps}.

Após obtermos os dados mencionados anteriormente foram implementados
\textit{scripts} para a geração dos arquivos de entrada do simulador, assim
como para popular o banco de dados da plataforma com as vagas de
estacionamento, sendo essas recursos da cidade. Os \textit{scripts} estão
disponíveis para verificação
\footnote{\url{https://github.com/LSS-USP/smart-city-platform-experiments/tree/master/data_scripts}}.
O \textit{UUID} (\textit{Universally Unique IDentifier}) das vagas tanto no
simulador quanto na plataforma são os mesmos, para que fosse possível a
identificação da mesma vaga nos dois sistemas facilmente.

Na Listagem \ref{code:spots} é apresentado um recorte do arquivo de entrada da
simulação contendo uma lista de vagas de estacionamento a serem utilizadas.
Cada linha com a tag \textit{spot} representa uma vaga de estacionamento
dentro da simulação, e cada vaga é posicionada em um nó (\textit{node}) do
grafo que representa a infraestrutura rodoviária da cidade. Do forma que foi
modelado, todas as vagas são posicionadas em algum nó do grafo, ou seja, no
encontro de ruas.  Além disso, cada vaga já possui o seu próprio \textit{UUID}
que é o mesmo presente na plataforma.

\lstset{
    language=xml,
    tabsize=3,
    frame=lines,
    caption=Arquivo de entrada contendo as vagas de estacionamento,
    label=code:spots,
    frame=shadowbox,
    rulesepcolor=\color{gray},
    xleftmargin=20pt,
    framexleftmargin=15pt,
    keywordstyle=\color{blue}\bf,
    commentstyle=\color{OliveGreen},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    breaklines=true,
    showstringspaces=false,
    basicstyle=\footnotesize,
    emph={uuid,node},emphstyle={\color{magenta}}}
    \lstinputlisting{files/park.xml}

Na Lista \ref{code:trips} é apresentado um recorte do arquivo de entrada da
simulação contendo as viagens a serem realizadas. Cada linha contendo a tag
\textit{trip} representa a viagem de um ou mais agentes na simulação, apesar do
simulador suportar viagens multimodais, como apresentado na Seção
\ref{sec:simulador}, para esse teste utilizamos apenas viagens de carro. Cada
viagem possui uma origem (\textit{origin}) e um destino (\textit{destination}),
sendo esses nós do grafo contendo a infraestrutura rodoviária; o sentido da
rua de partida (\textit{link\_origin}), já que a origem é um nó do grafo é
necessário saber para qual aresta de saída vamos partir; um contador
representando o número de atores que executarão aquela viagem (\textit{count});
e o tempo de simulação que irá iniciar a viagem em segundos (\textit{start}).

\lstset{
    language=xml,
    tabsize=3,
    frame=lines,
    caption=Arquivo de entrada contendo viagens,
    label=code:trips,
    frame=shadowbox,
    rulesepcolor=\color{gray},
    xleftmargin=20pt,
    framexleftmargin=15pt,
    keywordstyle=\color{blue}\bf,
    commentstyle=\color{OliveGreen},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    breaklines=true,
    showstringspaces=false,
    basicstyle=\footnotesize,
    emph={origin,link_origin,destination,count,start},emphstyle={\color{magenta}}}
    \lstinputlisting{files/trips.xml}

\textbf{Daqui para frente depende dos dados de um experimento, mas o script já
está feito. Talvez necessite de alguns pequenos ajustes apenas.}

Os arquivos de entrada contêm 500 mil vagas de estacionamento e 1 milhão de
viagens, levando em consideração o fluxo de carros da cidade de São Paulo entre
6h e 10h. Durante a simulação foi feito o registro do tempo em que foi feito a
requisição para a plataforma, o tempo em que foi recebida a resposta, e se a
mesma obteve sucesso ou não. A seguir serão apresentados resultados
preliminares do teste de desempenho realizado acerca do tempo de resposta
(\textit{response time}) e taxa de transferência (\textit{throughput}) da
plataforma.

A carga realizada pelo simulador na plataforma pode ser vista na Figura
\ref{fig:load}, onde pode-se ver o número de requisições realizadas em cada
tempo de simulação.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.5\textwidth]{scripts/load.png}
	\caption{Carga realizada na plataforma InterSCity via o simulador
	InterSCSimulator}
	\label{fig:load}
\end{figure}

A Figura \ref{fig:rate} apresenta a taxa de requisições que foram respondidas
com sucesso ou não pela plataforma durante o teste. (EXPLICAÇÃO QUANDO TIVER
DADOS REAIS)

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.5\textwidth]{scripts/rate.png}
	\caption{\textit{Status} das respostas da plataforma InterSCity}
	\label{fig:rate}
\end{figure}

A Figura \ref{fig:response_time} nos mostra no eixo x o tempo necessário para a
plataforma responder uma requisição e no eixo y a quantidade de requisições que
foram respondidas naquele tempo, representando assim o \textit{response time}
da plataforma. (EXPLICAÇÃO QUANDO TIVER DADOS REAIS)

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.5\textwidth]{scripts/response_time.png}
	\caption{Tempo de respostas da plataforma InterSCity}
	\label{fig:response_time}
\end{figure}

A Figura \ref{fig:throughtput} representa a taxa de vazão do sistema, ou seja,
quantas requisições foram respondidas com sucesso naquele segundo. (EXPLICAÇÃO
QUANDO TIVER DADOS REAIS)

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.5\textwidth]{scripts/throughput.png}
	\caption{Taxa de vazão da plataforma InterSCity}
	\label{fig:throughtput}
\end{figure}

Em resumo, com a infraestrutura provida pela integração da plataforma
InterSCity e o simulador InterSCSimulator nos permitiu realizar testes de
desempenho na escala da cidade de São Paulo em um cenário realista, mostrando
a viabilidade da proposta trazida para esta pesquisa.
