\chapter{Teste de Desempenho em Larga Escala para Cidades Inteligentes}
\label{cap:geracao_de_cenarios_de_teste}

%Para a realização de testes de desempenho para aplicações e sistemas na escala
%e condizentes com o contexto de grandes cidades existem alguns desafios. A
%dificuldade na geração de cenários realistas é um deles. Cidades são complexas,
%devemos tratar as relações interdomínios e sua propensão a acontecimentos
%inesperados. Além do mais, grandes cidades gerarão uma grande massas de dados.
%Neste trabalho defendemos que simuladores de Cidades Inteligentes de larga
%escala são ferramentas capazes de solucionar tais problemas, sendo a simulação
%uma das técnicas utilizadas para a realização de testes de desempenho. Cenários
%complexos envolvendo multiplos domínios advindos de simuladores podem gerar
%cargas condizentes com uma metrópole.

Testes de desempenho devem ser incorporados no ciclo desenvolvimento de
sistemas e aplicações de Cidades Inteligentes, já que queremos garantir que
esses sistemas irão prover um serviço de qualidade para a população.
Entretanto, existem alguns desafios a serem solucionados, o que dificulta a
realização dessa atividade. Cidades são complexas, e por isso devemos ser
capazes de tratar as relações interdomínios e sua propensão a acontecimentos
inesperados.  Além do mais, grandes cidades possuirão uma infraestrutura de
\textit{IoT} de larga escala, e esses sistemas devem ser capazes de interagir
com toda essa rede de sensores e atuadores. Com os cenários complexos advindos
de simulações espera-se realizar testes de carga, e que seja possível a
identificaçõe de gargalos nos sistemas o mais cedo possível no ciclo de
desenvolvimento. Assim, reduzindo o custo para correção e garantindo que os
usuários terão uma boa experiência utilizando o serviço quando estiver
disponível.

Com a disponibilização desse ambiente para a realização de testes de
desempenho, auxiliaremos desenvolvedores de sistemas e aplicações para Cidades
Inteligentes a encontrarem gargalos antes de os mesmos impactarem de alguma
forma a cidade. Esses gargalos poderão estar relacionados tanto com a
implementação quanto com a implantação do sistema.  Consultas ao banco de dados
não otimizadas, mal gerenciamento de conexões abertas com outras aplicações e
operações de entrada e saída desnecessárias são exemplos de possíveis problemas
de implementação do sistema. Em geral, a resolução de gargalos gerados devido a
problemas de implementação envolvem a otimização de algum algoritmo ou técnica
utilizada para aquele contexto.  Contudo, o problema encontrado pode ser
referente a implantação do sistema.  Escassez de recursos computacionais
(envolvendo memória, processamento e rede) ou configuração errada de algum
componente ou serviço podem ser motivos para a geração de gargalos. Uma solução
recorrente para esse tipo de problema é escalar o sistema, seja horizontalmente
ou verticalmente. A automação da implantação de sistemas é uma boa prática,
pois facilita a resolução de problemas de configuração (solução em código-fonte
ou \textit{script}) e permite replicar o ambiente facilmente para a realização
de novos testes.

%cidades estão inseridas em contextos dinâmicos e imprevisíveis, e
%gerar cargas que se assemelham ao que acontece no dia-a-dia é uma tarefa
%complexa. Como simuladores possuem modelos que visam representar a realidade,
%inclusive picos e acontecimentos inesperados, eles se apresentam como uma
%potencial solução. Com os dados de tais simulações espera-se realizar testes de
%carga, e que seja possível a identificaçõe de gargalos nos sistemas o mais cedo
%possível no ciclo de desenvolvimento, reduzindo o custo para correção e
%garantindo que os usuários terão uma boa experiência utilizando o serviço
%quando estiver disponível.  Dependendo da implementação e implantação do
%sistema, esses testes de carga podem se tornar de estresse podendo levar a
%problemas como indisponibilidade do sistema. Nesse caso tal sistema não
%suportaria a carga gerada pela cidade em questão, necessitando de uma
%reorganização visando escalabilidade.

Defendemos que a utilização de simuladores de Cidades Inteligentes de larga
escala são potenciais soluções para facilitar a realização de testes de
desempenho. Para realizar esses testes em sistemas e aplicações para Cidades
Inteligentes, simuladores devem ser capazes de simular dispositivos de
\textit{IoT} que monitorem e atuem no contexto da cidade; possuir modelos que
representam o ambiente urbano de maneira realista, representando toda a
dinâmica e peculiaridades da cidade; gerar massa de dados na escala da cidade;
e conseguir se comunicar com os sistemas usando os seus respectivos protocolos.
Com isso, o simulador será capaz de gerar o ambiente necessário para realização
dos testes. Simuladores já vêm sendo usados para teste de cenários complexos em
outras áreas de pesquisa \cite{mclaren_1992} \cite{mccown_1996}
\cite{dominguez_08} \cite{walker_1998}.

Como prova de conceito da utilização de simuladores na realização de testes de
desempenho em sistemas e aplicações de Cidades Inteligentes, foi realizada uma
integração inicial entre a plataforma InterSCity e o simulador
InterSCSimulator. Nessa integração foi tratado um cenário específico, onde são
simulados carros realizando viagens pela cidade e, ao final de cada viagem, o
agente tenta encontrar uma vaga de estacionamento disponível mais próxima para
estacionar.

No decorrer deste capítulo, serão apresentados I) a implementação desse cenário
de simulação, contendo movimentação de carros pela cidade e procura de vagas de
estacionamento, II) exemplo de integração do simulador e da plataforma, e
III) resultados a cerca de um experimento de pequena escala realizado como
prova de conceito da integração feita. Ao final deste capítulo será possível
perceber a viabilidade da realização de testes e experimentos de desempenho de
larga escala na plataforma através do simulador.


\section{Simulação de Busca por Vagas de Estacionamento}
\label{sec:simulation}

Até o início deste trabalho, o InterSCSimulator suportava cenários de
mobilidade, ou seja, eram simuladas viagens de pessoas na cidade andando, de
carro, ônibus e metrô. Durante o início desta pesquisa, esse domínio de
mobilidade foi estendido para contemplar a busca de vagas de estacionamento por
carros ao final de suas viagens.

Como entrada da simulação são passados o grafo representando a infraestrutura
rodoviária da cidade, onde as arestas representam ruas e os nós esquinas entre
duas ou mais ruas; e a configuração das viagens, especificando a origem e
destino de cada agente da simulação e o modo de viagem, podendo ser carro,
ônibus, metrô ou a pé.  Para incrementar vagas de estacionamento à simulação
foi adicionada uma nova entrada onde é listado todo o conjunto de vagas da
cidade, indicando em que nó do grafo da cidade cada vaga de estacionamento se
encontra (apesar de boa parte das vagas estarem presentes nas arestas, não
guardamos informações nelas, por isso simplificamos colocando-as no nó mais
próximo); bem como foi adicionado a cada uma das viagens em qual vaga o agente
irá estacionar ao chegar no término da viagem, considerando que a vaga de
estacionamento a ser utilizada é conhecida previamente.

Durante a simulação, cada agente é criado e realiza o seu percurso normalmente,
saindo do sua origem até o seu destino. Ao se aproximar do seu destino o
simulador recalcula a sua rota para chegar na vaga de estacionamento
previamente especificada. A seguir é apresentado todo o ciclo de simulação de
um agente nesse cenário:

\begin{enumerate}
	\item O agente é criado
	\item O caminho mais curto entre a origem e o destino é calculado
	\item O agente parte da sua origem no tempo determinado
	\item Ao chegar no nó anterior ao seu destino, a rota é recalculada em
	direção à vaga de estacionamento
	\item O agente estaciona na vaga de estacionamento previamente determinada
	via arquivo de configuração
\end{enumerate}

Um esquema simples foi implementado para a liberação das vagas de
estacionamento, onde após um tempo fixo depois da ocupação ela é liberada.
Na implementação atual, a configuração de tempo é de 10 minutos. Esse é um dos
pontos passíveis de melhoria no decorrer do trabalho, onde é necessário
encontrar modelos que representem melhor a realidade.

A partir dessa implementação foi possível realizar simulações contemplando
questões de mobilidade, inclusive a busca por vagas de estacionamento por
carros ao final de suas viagens. Uma das dificuldades para realizar a simulação
desse novo cenário é a necessidade de saber previamente onde cada agente que
representa um carro irá estacionar. Isso porque mais de um agente não pode ter
como destino a mesma vaga de estacionamento enquanto outro a estiver ocupando,
o que leva a uma complexidade maior na geração dos arquivos de entrada. Esse
problema foi solucionado com a integração do simulador com a plataforma
InterSCity que será apresentada na próxima seção.


\section{Exemplo de Integração entre InterSCSimulator e Plataforma InterSCity}
\label{sec:integration}

A integração inicial entre o InterSCSimulator e a plataforma InterSCity foi
feita com o intuito de gerar uma carga realista para a realização de testes de
desempenho na plataforma. Como foi discutido no início do capítulo, alguns
passos devem ser seguidos para que seja possível a realização de testes de
desempenho na plataforma InterSCity usando o InterSCSimulator, sendo eles:

\begin{itemize}
	\item Simular dispositivos de Internet das Coisas
	\item Gerar massa de dados na escala de uma cidade
	\item Comunicar via protocolos já utilizados pela plataforma
\end{itemize}

%Os dois primeiros itens são contemplados pelo simulador, em que os dispositivos
%de \textit{IoT} de monitoramento de vagas são simulados e geram uma massa de
%dados na escala de uma cidade, caso seja definido um cenário de simulação desse
%porte. Para o último passo, foi implementado no simulador a publicação de
%eventos via \textit{RabbitMQ}, mesmo protocolo utilizado pela plataforma.

Considerando o cenário de simulação apresentado na seção anterior, os dois
primeiros itens são contemplados pelo simulador. As vagas de estacionamento
seriam recursos da cidade monitorados por algum tipo de dispositivo de
\textit{IoT}. Tais dispositivos seriam capazer de monitorar o estado da vaga,
podendo ser ocupada ou livre. Durante a simulação, o estado desses recursos
seria atualizado sempre que necessário, ou seja, no momento em que um carro
estacionasse ou saísse da vaga de estacionamento. Esses dispositivos simulados
podem gerar massa de dados na escala de uma cidade, caso seja definido um
cenário de simulação desse porte. Para o último passo, foi implementado no
simulador a publicação de eventos via \textit{RabbitMQ}, mesmo protocolo
utilizado pela plataforma.

A integração consistiu na utilização do microserviço \textit{Resource
Discovery} para encontrar a vaga de estacionamento mais próxima do destino da
viagem de cada carro, assim como a atualização do estado da vaga. Para a
utilização do serviço de descoberta provido pelo \textit{Resource Discovery}
foi usada a sua API \textit{Restful}. Para a atualização do estado das vagas
foi utilizado o \textit{RabbitMQ}.  O ponto interessante dessa integração é que
exercemos carga na plataforma do ponto de vista de uma aplicação que utiliza os
serviços providos, e também do ponto de vista de dispositivos de \textit{IoT}
que desejam atualizar o estado de recursos da cidade. As Figuras
\ref{fig:descoberta} e \ref{fig:atualizacao} detalham essa integração de duas
vias.

A Figura \ref{fig:descoberta} apresenta a integração realizada para utilização
do serviço de descoberta provido pela plataforma InterSCity.  Para isso foi
utilizado um agente externo chamado \textit{Parking Spot Discoverer}, que fez o
papel de um middleware entre os dois sistemas. O uso desse \textit{middleware}
se fez necessário para que a simulação exerça a carga que aplicações exerceriam
utilizando o protocolo \textit{HTTP} para acessar a API \textit{Restful}. Como
requisições \textit{HTTP} são síncronas, a realização das mesmas dentro da
simulação atrasaria consideravelmente a sua finalização, já que bloquearia a
execução dos agentes enquanto aguardariam a resposta da plataforma. Antes de
chegarmos a tal solução implementamos uma versão onde o próprio simulador
realizava requisições \textit{HTTP} para a plataforma em tempo de simulação,
entretanto, essa solução gerou um gargalo na simulação. Descrevemos abaixo o
fluxo de atividades apresentado na Figura \ref{fig:descoberta}.

\begin{enumerate}
	\item Ao chegar um nó antes do seu destino, o carro solicita a vaga de
	estacionamento para o \textit{Parking Controller Agent}, passando a sua
	localização como parâmetro.

	\item O \textit{Parking Controller Agent} então envia a localização para o
	\textit{Parking Spot Discoverer} e solicita a vaga disponível mais próxima,
	em um raio de 500 metros.

	\item O \textit{Parking Spot Discoverer} faz uma requisição \textit{HTTP}
	para o serviço de descoberta da plataforma que retorna a vaga em questão.
	Caso não seja encontrada uma vaga disponível (não ocupada) em um raio de
	500 metros, esse raio é multiplicado por dois até que se encontre uma vaga
	disponível.

	\item O identificador da vaga é retornado para o \textit{Parking
	Controller Agent} e ele marca a vaga como utilizada em uma estrutura
	de dados mantida no simulador.

	\item O identificador da vaga é recebido pelo agente que representa o carro
	e a rota é recalculada para chegar até ela.
\end{enumerate}

\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{figures/integration_get_data.png}
	\caption{Integração para descoberta de vagas livres próximo do destino da
	viagem}
	\label{fig:descoberta}
\end{figure}

A Figura \ref{fig:atualizacao} apresenta a integração realizada com o intuito
de atualizar o estado das vagas de estacionamento na plataforma baseado nos
acontecimentos da simulação. Foi adicionado no simulador a funcionalidade de
publicação dos eventos da simulação via protocolo \textit{AMQP} para os
interessados. Com isso, não foi necesário a utilização de um agente externo, já
que a plataforma também utiliza o mesmo protocolo para divulgação dos seus
dados entre microsserviços. O fluxo apresentado na Figura \ref{fig:atualizacao}
contém os seguintes passos.

\begin{enumerate}
	\item O agente carro estaciona na vaga de estacionamento e notifica o
	\textit{Parking Controller}.

	\item O \textit{Parking Controller} informa, via \textit{RabbitMQ}, que a
	vaga está ocupada usando o seu identificador.

	\item O \textit{RabbitMQ} repassa esse dado para os microsserviços
	\textit{Resource Catalog} e \textit{Data Collector}.
\end{enumerate}

\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{figures/integration_publish_data.png}
	\caption{Integração para publicar dados}
	\label{fig:atualizacao}
\end{figure}

Vale ressaltar que as atividades 2 e 3 apresentadas na Figura
\ref{fig:atualizacao} são executadas quando a vaga é liberada. Após dez minutos
que o agente está estacionado na vaga, o \textit{Parking Controller Agent}
libera a vaga na estrutura de dados mantida dentro do simulador e informa o
ocorrido para a plataforma. Com isso, a plataforma atualiza os dados da vaga
tanto quando ela é ocupada quando liberada.

Uma das limitações apresentadas é que todas as vagas de estacionamento devem
ser criadas previamente na plataforma para que as integrações apresentadas
funcionem como o esperado, sendo esse mais um ponto para evolução no decorrer
do trabalho.

\section{Resultados Preliminares}
\label{sec:resultados}

Como o objetivo de validar a simulação e a integração apresentadas nas seções
anteriores foi executada uma simulação de um cenário envolvendo a cidade de São
Paulo para a realização de testes de desempenho do serviço de descoberta de
recursos da plataforma InterSCity.  Foram utilizados dados da pesquisa de
origem
destino\footnote{\url{http://www.metro.sp.gov.br/metro/arquivos/OD2007/sintese-od2007.pdf}}
realizado pela Companhia de Metrô de São Paulo em 2007 para a geração das
viagens de carro e as vagas de estacionamento oriundas dos dados de Zona
Azul\footnote{\url{http://www.cetsp.com.br/consultas/zona-azul/mapa-zona-azul/mapa-zona-azul.aspx}}
e do \textit{Open Street
Maps}\footnote{\url{http://wiki.openstreetmap.org/wiki/Tag:amenity\%3Dparking}}.

Após obtermos os dados mencionados anteriormente foram implementados
\textit{scripts}\footnote{\url{https://github.com/LSS-USP/smart-city-platform-experiments/tree/master/data_scripts}}
para a geração dos arquivos de entrada do simulador, assim como para popular o
banco de dados da plataforma com as vagas de estacionamento. Usamos um mesmo
\textit{UUID} (\textit{Universally Unique IDentifier}) das vagas tanto no
simulador quanto na plataforma, para que fosse possível a
identificação da mesma vaga nos dois sistemas facilmente.

Na Listagem \ref{code:spots} é apresentado um recorte do arquivo de entrada da
simulação contendo uma lista de vagas de estacionamento a serem utilizadas.
Cada linha com a tag \textit{spot} representa uma vaga de estacionamento
dentro da simulação, e cada vaga é posicionada em um nó (\textit{node}) do
grafo que representa a infraestrutura rodoviária da cidade. Da forma que foi
modelado, todas as vagas são posicionadas em algum nó do grafo, ou seja, no
encontro de ruas.  Além disso, cada vaga já possui o seu próprio \textit{UUID}
que é o mesmo presente na plataforma.

\lstset{
    language=xml,
    tabsize=3,
    frame=lines,
    caption=Arquivo de entrada contendo as vagas de estacionamento,
    label=code:spots,
    frame=shadowbox,
    rulesepcolor=\color{gray},
    xleftmargin=20pt,
    framexleftmargin=15pt,
    keywordstyle=\color{blue}\bf,
    commentstyle=\color{OliveGreen},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    breaklines=true,
    showstringspaces=false,
    basicstyle=\footnotesize,
    emph={uuid,node},emphstyle={\color{magenta}}}
    \lstinputlisting{files/park.xml}

Na Listagem \ref{code:trips} é apresentado um recorte do arquivo de entrada da
simulação contendo as viagens a serem realizadas. Cada linha contendo a tag
\textit{trip} representa a viagem de um ou mais agentes na simulação. Apesar do
simulador permitir viagens multimodais, para esse teste utilizamos apenas
viagens de carro. Cada viagem possui uma origem (\textit{origin}) e um destino
(\textit{destination}), sendo esses nós do grafo da infraestrutura rodoviária;
o sentido da rua de partida (\textit{link\_origin}), já que a origem é um nó do
grafo, é necessário saber para qual aresta de saída vamos partir; um contador
representando o número de atores que executarão aquela viagem (\textit{count});
e o tempo de simulação que irá iniciar a viagem em segundos (\textit{start}).

\lstset{
    language=xml,
    tabsize=3,
    frame=lines,
    caption=Arquivo de entrada contendo viagens,
    label=code:trips,
    frame=shadowbox,
    rulesepcolor=\color{gray},
    xleftmargin=20pt,
    framexleftmargin=15pt,
    keywordstyle=\color{blue}\bf,
    commentstyle=\color{OliveGreen},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    breaklines=true,
    showstringspaces=false,
    basicstyle=\footnotesize,
    emph={origin,link_origin,destination,count,start},emphstyle={\color{magenta}}}
    \lstinputlisting{files/trips.xml}


Para testar a integração realizada foi feito um teste de desempenho inicial de
pequena escala com máquinas contendo poucos recursos computacionais. Estamos
realizando testes de desempenho com o mesmo cenário aqui apresentado em larga
escala e em um ambiente de implantação mais realista, mas ainda não foi
possível finaliza-lo para apresentação dos resultados. Nesse teste inicial
foram utilizados dois \textit{laptops} que possuiam 8 GB de memória RAM, uma
CPU 1.90GHz com 4 núcleos, executando um sistema operacional Debian Sid com
Linux versão 4.13.0. Um \textit{laptop} foi utilizado para a execução da
plataforma como um todo e o outro para o simulador. O cenário de teste envolvia
1000 carros se movendo na cidade de São Paulo de 6h até 7h30 da manhã, sendo
que haviam 1600 vagas espalhadas disponíveis. Durante a simulação foi feito o
registro do tempo em que foi feito a requisição para a plataforma, o tempo em
que foi recebida a resposta, e se a mesma obteve sucesso ou não. A seguir serão
apresentados resultados preliminares do teste experimental de desempenho
realizado acerca do tempo de resposta e vazão do serviço de descoberta de
recursos da plataforma.

%Para a realização desse teste inicial da integração foram utilizados dois
%computadores pessoais com 8 GB de memória RAM e 4 CPUs, um executando todos os
%microserviços da plataforma e outro executando o simulador. O cenário de teste
%envolvia 1000 carros se movendo na cidade de São Paulo de 6h até 7h30 da manhã,
%sendo que haviam 1600 vagas espalhadas disponíveis. Durante a simulação foi
%feito o registro do tempo em que foi feito a requisição para a plataforma, o
%tempo em que foi recebida a resposta, e se a mesma obteve sucesso ou não. A
%seguir serão apresentados resultados preliminares do teste experimental de
%desempenho realizado acerca do tempo de resposta (\textit{response time}) e
%vazão (\textit{throughput}) do serviço de descoberta de recursos da plataforma.

A carga realizada pelo simulador na plataforma nesse teste pode ser vista na
Figura \ref{fig:load}, onde podemos ver o número de requisições realizadas por
minuto. Em média, dois segundo de simulação representou um segundo em tempo
real, isso ocorreu pelo fato de não termos muitos carros na simulação e os
\textit{ticks} de simulação ociosos serem executados de maneira mais rápida.
É possível perceber que no início da simulação um número menor de carros
requisitam vagas de estacionamento para a plataforma, já que grande maioria dos
carros ainda estão iniciando ou irão iniciar o seu trajeto. O pico de
requisições acontece próximo dos 37 minutos de teste, aproximadamente as 7h15
da manhã na simulação, onde 81 requisições foram realizadas para a plataforma
no mesmo minuto. Após esse horário de pico, a maioria dos carros já estão
chegando aos seus respectivos destinos e o número de requisições é reduzido.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.4\textwidth]{scripts/load.png}
	\caption{Carga realizada na plataforma InterSCity via o InterSCSimulator}
	\label{fig:load}
\end{figure}

A Figura \ref{fig:rate} apresenta o número de requisições que foram respondidas
com sucesso ou não pela plataforma durante o teste, sendo considerado sucesso
as requisições que retornaram o código \textit{HTTP} 200 e erro qualquer outro
código de retorno. Um pouco mais de 10\% das requisições foram respondidas sem
sucesso, sendo que esses erros aconteceram devido a \textit{timeouts} do
serviço da plataforma. Acreditamos que isso ocorreu pelo fato da máquina
utilizada para implantação da plataforma possuir poucos recursos
computacionais. Todavia, pode representar um gargalo na plataforma mesmo com
uma carga de pequena escala. Essa hipótese está sendo investigada nos testes de
desempenho de maior escala que estamos realizando.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.4\textwidth]{scripts/rate.png}
	\caption{Estado das respostas do serviço de descoberta da plataforma InterSCity}
	\label{fig:rate}
\end{figure}

Na Figura \ref{fig:response_time} temos a média do tempo de resposta do serviço
em questão por minuto. Aproximadamente 76\% das requisições respondidas com
sucesso demoraram até 10 segundos, essas ocorrendo até os 35 minutos de teste
(7h10 da manhã na simulação). Após esse momento, acreditamos que, devido a
falta de recursos computacionais e sendo esse o pico de requisições deste
teste (como pode ser visto na Figura \ref{fig:load}), a plataforma começou a
aumentar o seu tempo médio de resposta, e 6\% dessas respostas demoraram
mais de 50 segundos. 

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.4\textwidth]{scripts/response_time.png}
	\caption{Tempo de resposta do serviço de descoberta da plataforma InterSCity}
	\label{fig:response_time}
\end{figure}

A quantidade de requisições respondidas com sucesso por minuto é apresentada na
Figura \ref{fig:throughput}, representando a vazão do serviço de descoberta.
Podemos notar que a vazão cresce proporcionalmente ao número de requisições
realizadas até por volta dos 38 minutos de teste (7h15 da manhã na simulação).
Assim como o tempo médio de resposta, a vazão do serviço é degradada nesse
pico de requisições. Contudo o número de respostas também é reduzido devido à
chegada do término da simulação.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.4\textwidth]{scripts/throughput.png}
	\caption{Vazão do serviço de descoberta da plataforma InterSCity}
	\label{fig:throughput}
\end{figure}

Consideramos os testes iniciais de desempenho realizados a partir da integração
feita ainda não ideais devido a implantação da plataforma e simulador em
máquinas com poucos recursos computacionais. Mesmo realizando os testes nesse
contexto conseguimos estressar a plataforma, onde requisições foram respondidas
com erro (\textit{timeout}) mesmo diante de uma carga pequena. Estamos
trabalhando para a realização desse mesmo teste de desempenho em maior escala
(com 467744 vagas e 9329 veículos realizando trajetos de 6h às 9h da manhã em
São Paulo), com isso pretendemos identificar verdadeiros gargalos da plataforma
e solucioná-los. Para isso estamos automatizando uma implantação mais realista
no \textit{Google Cloud Platform}, utilizando algumas vantagens não exploradas
como a escalabilidade automática (\textit{auto-scaling}) dos microserviços da
plataforma.

A infraestrutura provida pela integração da plataforma InterSCity e o
simulador InterSCSimulator nos permitirá realizar testes de desempenho na
escala da cidade de São Paulo em um cenário realista, mostrando a viabilidade
da proposta trazida para esta pesquisa.
