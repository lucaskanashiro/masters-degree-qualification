\chapter{Teste de Desempenho em Larga Escala para Cidades Inteligentes}
\label{cap:geracao_de_cenarios_de_teste}

Como apresentado na Seção \ref{sec:analise_performance}, simulação é uma das
técnicas de avaliação utilizada em análises de desempenho.  Neste trabalho
defendemos que simuladores de Cidades Inteligentes são ferramentas capazes de
gerar cargas realistas para a realização de testes de desempenho em sistemas e
aplicações para tal contexto. Cenários complexos advindos de simuladores, onde
picos de cargas e eventos inesperados podem ser comtemplados, podem facilitar
tal tarefa. Além de permitirem testes e experimentos que envolvam atuação na
cidade.

Testes de desempenho devem ser incorporados no ciclo desenvolvimento de
sistemas e aplicações de Cidades Inteligentes, já que queremos que esses
serviços tenham alta disponibilidade.  Entretanto, cidades estão inseridas em
contextos dinâmicos e imprevisíveis, e gerar cargas que se assemelham ao que
acontece no dia-a-dia é uma tarefa complexa. Como simuladores possuem modelos
que visam representar a realidade, inclusive picos e acontecimentos
inesperados, eles se apresentam como uma solução. Com os dados de tais
simulações espera-se realizar testes de carga, e que seja possível a
identificaçõe de gargalos nos sistemas o mais cedo possível no ciclo de
desenvolvimento, reduzindo o custo para correção e garantindo que os usuários
terão uma boa experiência utilizando o serviço quando estiver disponível.
Dependendo da implementação e implantação do sistema, esses testes de carga
podem se tornar de estresse podendo levar a problemas como indisponibilidade do
sistema, nesse caso tal sistema não suportaria a carga gerada pela cidade em
questão, necessitando de uma refatoração visando escalabilidade.

Para realizar testes de desempenho em sistemas e aplicações em Cidades
Inteligentes simuladores devem ser capazes de simular dispositivos de
Internet das Coisas (\textit{IoT}) que monitorem e atuem no contexto da cidade;
possuir modelos que representam o ambiente urbano de maneira realista,
representando toda a dinâmica e peculiaridades da cidade; gerar massa de dados
na escala da cidade; e conseguir se comunicar com os sistemas usando os seus
respectivos protocolos. Com isso, o simulador será capaz de gerar o ambiente
necessária para realização dos testes. Simuladores já vêm sendo usados para
teste de cenários complexos em outras áreas de pesquisa \cite{mclaren_1992}
\cite{mccown_1996} \cite{dominguez_08} \cite{walker_1998}.

Como prova de conceito da utilização de simuladores na realização de testes de
desempenho em sistemas e aplicações de Cidades Inteligentes, foi realizada uma
integração inicial entre a plataforma InterSCity e o simulador
InterSCSimulator. Nessa integração foi tratado um cenário específico, onde são
simulados carros realizando viagens pela cidade e ao final de cada viagem o
agente tenta encontrar uma vaga de estacionamento disponível mais próxima para
estacionar.

No decorrer deste capítulo serão apresentados I) a implementação desse novo
cenário de simulação, contendo movimentação de carros pela cidade e procura de
vagas de estacionamento e II) a integração preliminar do simulador e da
plataforma. Sendo assim possível realizar testes e experimentos de desempenho
na plataforma através do simulador.

\section{Simulação de Múltiplos Domínios}
\label{sec:simulation}

O InterSCSimulator é um simulador \textit{Open-Source} e escalável para Cidades
Inteligentes que tem como objetivo simular vários cenários complexos de larga
escala \cite{santana_17}. Até o início deste trabalho apenas cenários de
mobilidade eram suportados, ou seja, eram simuladas viagens de pessoas na
cidade andando, de carro, ônibus e metrô. Durante o início desta pesquisa foi
implementado um novo cenário que contempla a busca de vagas de estacionamento
por carros ao final das suas viagens.

Como entrada da simulação são passados o grafo representando a infraestrutura
rodoviária da cidade, onde as arestas representam ruas e os nós esquinas entre
duas ou mais ruas; e a configuração das viagens, especificando a origem e
destino de cada agente da simulação e o modo de viagem, sendo todos carros em
nossos testes.  Para incrementar vagas de estacionamento à simulação foi
adicionada uma nova entrada onde é listado todo o conjunto de vagas da cidade,
indicando em que nó do grafo da cidade cada vaga de estacionamento se encontra;
bem como foi adicionado a cada uma das viagens em qual vaga o agente irá
estacionar ao chegar no término da viagem, considerando que a vaga de
estacionamento a ser utilizada é conhecida previamente.

Durante a simulação, cada agente é criado e realiza o seu percurso normalmente,
saindo do sua origem até o seu destino. Ao se aproximar do seu destino o
simulador recalcula a sua rota para chegar na vaga de estacionamento
previamente especificada. A seguir é apresentado todo o ciclo de simulação de
um agente nesse cenário:

\begin{enumerate}
	\item Agente é criado
	\item O caminho mais curto entre a origem e o destino é calculado
	\item Parte da sua origem no tempo determinado
	\item Ao chegar no nó anterior ao seu destino, a rota é recalculada em
	direção a vaga de estacionamento
	\item Agente estaciona na vaga de estacionamento previamente determinada
\end{enumerate}

Um esquema simples foi implementado para a liberação das vagas de
estacionamento, onde após um tempo fixo depois da ocupação ela é liberada,
na implementação atual, a configuração de tempo é de 10 minutos. Esse é um dos
pontos passíveis de melhoria no decorrer do trabalho, onde é necessário
encontrar modelos que representem melhor a realidade.

A partir dessa implementação foi possível realizar simulações contemplando
tanto a questão de mobilidade em uma cidade quanto o estacionamento de carros
ao final de suas viagens. Uma das dificuldades para realizar a simulação desse
novo cenário é a necessidade de saber previamente onde cada agente que
representa um carro irá estacionar. Isso porque mais de um agente não pode ter
como destino a mesma vaga de estacionamento enquanto outro a estiver ocupando,
o que leva a uma complexidade maior na geração dos arquivos de entrada. Esse
problema foi solucionado com a integração do simulador com a plataforma
InterSCity que será apresentada na próxima seção.


\section{Integração entre InterSCSimulator e InterSCity}
\label{sec:integration}

A integração inicial entre o simulador InterSCSimulator e a plataforma
InterSCity foi feita com o intuito de gerar uma carga realista para a
realização de testes de desempenho na plataforma. Bem como foi apresentado no
início deste capítulo, existem alguns requisitos que devem ser implementados
para que seja possível a realização de testes de desempenho na plataforma
InterSCity usando o simulador InterSCSimulator, sendo eles:

\begin{itemize}
	\item Simular dispositivos de Internet das Coisas
	\item Gerar massa de dados na escala de uma cidade
	\item Comunicar via protocolos já utilizados pela plataforma
\end{itemize}

Como apresentado na Seção \ref{sec:interscity}, a plataforma InterSCity
trabalha com os conceitos de recursos da cidade e suas respectivas capacidades
de sensoriamento ou atuação. Além disso, utiliza-se de dois tipos diferentes de
comunicação: síncrona, através de API \textit{Restful}; e assíncrona, através do
protocolo AMQP.

No cenário apresentado na seção anterior, as vagas de estacionamento seriam
recursos da cidade monitorados por algum tipo de dispositivo de Internet das
Coisas. Tais dispositivos seriam capazer de monitorar o estado da vaga, podendo
ser ocupada ou livre. Durante a simulação o estado desses recursos seriam
atualizados sempre que necessário, ou seja, no momento em que um carro
estacionasse ou saísse da vaga de estacionamento.

A integração consistiu na utilização do microserviço \textit{Resource
Discovery} para encontrar a vaga de estacionamento mais próxima do destino da
viagem de cada carro, assim como a atualização do estado da vaga. Para a
utilização do serviço de descoberta provido pelo \textit{Resource Discovery}
foi usada a sua API \textit{Restful}, e o \textit{RabbitMQ} (uma implementação
do protocolo AMQP) foi usado para a atualização do estado das vagas. O ponto
interessante dessa integração é que exercemos carga na plataforma tanto como
uma aplicação que utiliza os serviços providos, como dispositivos de Internet
das Coisas que desejam atualizar o estado de recursos da cidade. As Figuras
\ref{fig:descoberta} e \ref{fig:atualizacao} serão utilizadas para detalhar
essa integração de duas vias.

A Figura \ref{fig:descoberta} apresenta a integração realizada para utilização
do serviço de descoberta provido pela plataforma InterSCity.  Para isso foi
utilizado um agente externo chamado \textit{Parking Spot Discoverer}, que fez o
papel de um \textit{middleware} entre os dois sistemas. O uso desse
\textit{middleware} se fez necessário para que a simulação exerça a carga que
aplicações exerceriam utilizando o protocolo \textit{HTTP} para acessar a API
\textit{Restful}. Como requisições \textit{HTTP} são síncronas, a realização
das mesmas dentro da simulação atrasaria consideravelmente a sua finalização,
já que bloquearia a execução dos agentes enquanto aguardariam a resposta da
plataforma. Antes de chegarmos a tal solução implementamos uma versão onde o
próprio simulador realizava requisições \textit{HTTP} para a plataforma em
tempo de simulação, entretanto, essa solução gerou um gargalo na simulação.
Abaixo será descrito o fluxo de atividades apresentado na Figura
\ref{fig:descoberta}.

\begin{enumerate}
	\item Ao chegar um nó antes do seu destino, o carro solicita a vaga de
	estacionamento para o \textit{Parking Controller}, passando a sua
	localização como parâmetro.

	\item O \textit{Parking Controller} então envia a localização para o
	\textit{Parking Spot Discoverer} e solicita a vaga disponível mais próxima,
	em um raio de 500 metros.

	\item O \textit{Parking Spot Discoverer} faz uma requisição \textit{HTTP}
	para o serviço de descoberta da plataforma e ele retorna a vaga em questão.
	Caso não seja encontrada uma vaga disponível em um raio de 500 metros, esse
	raio é multiplicado por dois até que se encontre uma vaga disponível.

	\item O identificador da vaga é retornado para o \textit{Parking
	Controller} e ele marca a vaga como utilizada em uma estrutura
	de dados mantida no simulador.

	\item O identificador da vaga é recebido pelo agente que representa o carro
	e a rota é recalculada para chegar até ela.
\end{enumerate}

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.35\textwidth]{figures/integration_get_data.png}
	\caption{Integração para descoberta de vagas livres próximo do destino da
	viagem}
	\label{fig:descoberta}
\end{figure}

A Figura \ref{fig:atualizacao} apresenta a integração realizada com o intuito
de atualizar o estado das vagas de estacionamento na plataforma baseado nos
acontecimentos da simulação. Foi adicionado no simulador a funcionalidade de
publicação dos eventos da simulação via protocolo \textit{AMQP} para os
interessados, com isso não foi necesário a utilização de um agente externo, já
que a plataforma também utiliza o mesmo protocolo para divulgação dos seus
dados entre microserviços. A seguir será apresentado mais detalhadamente esse
fluxo.

\begin{enumerate}
	\item O agente carro estaciona na vaga de estacionamento e notifica o
	\textit{Parking Controller}.

	\item O \textit{Parking Controller} publica, via \textit{RabbitMQ}, que a
	vaga está ocupada usando o seu identificador.

	\item O \textit{RabbitMQ} repassa esse dado par os microserviços
	\textit{Resource Catalog} e \textit{Data Collector}, entretanto esse dado
	só é utilizado pelo \textit{Data Collector}.
\end{enumerate}

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.35\textwidth]{figures/integration_publish_data.png}
	\caption{Integração para publicar dados}
	\label{fig:atualizacao}
\end{figure}

Vale ressaltar que o fluxo apresentado na Figura \ref{fig:atualizacao} também é
executado quando a vaga é ocupada, entre os passos 4 e 5 da Figura
\ref{fig:descoberta}. Com isso, a plataforma atualiza os dados da vaga tanto
quando a mesma é ocupada quando liberada.

Uma das limitações apresentadas é que todas as vagas de estacionamento devem
ser criadas previamente na plataforma para que as integrações apresentadas
funcionem como o esperado, sendo esse mais um ponto para evolução no decorrer
do trabalho.

\section{Resultados Preliminares}
\label{sec:resultados}

Como o objetivo de validar a simulação e a integração apresentadas nas seções
anteriores foi executada uma simulação de um cenário envolvendo a cidade de São
Paulo para a realização de testes de desempenho do serviço de descoberta de
recursos da plataforma InterSCity.  Foram utilizados dados da pesquisa de
origem destino realizado pela Companhia de Metrô de São Paulo em 2007 para a
geração das viagens de carro e as vagas de estacionamento oriundas dos dados de
Zona Azul e do \textit{Open Street Maps}.

Após obtermos os dados mencionados anteriormente foram implementados
\textit{scripts} para a geração dos arquivos de entrada do simulador, assim
como para popular o banco de dados da plataforma com as vagas de
estacionamento, sendo essas recursos da cidade. Os \textit{scripts} estão
disponíveis para verificação
\footnote{\url{https://github.com/LSS-USP/smart-city-platform-experiments/tree/master/data_scripts}}.
O \textit{UUID} (\textit{Universally Unique IDentifier}) das vagas tanto no
simulador quanto na plataforma são os mesmos, para que fosse possível a
identificação da mesma vaga nos dois sistemas facilmente.

Na Listagem \ref{code:spots} é apresentado um recorte do arquivo de entrada da
simulação contendo uma lista de vagas de estacionamento a serem utilizadas.
Cada linha com a tag \textit{spot} representa uma vaga de estacionamento
dentro da simulação, e cada vaga é posicionada em um nó (\textit{node}) do
grafo que representa a infraestrutura rodoviária da cidade. Da forma que foi
modelado, todas as vagas são posicionadas em algum nó do grafo, ou seja, no
encontro de ruas.  Além disso, cada vaga já possui o seu próprio \textit{UUID}
que é o mesmo presente na plataforma.

\lstset{
    language=xml,
    tabsize=3,
    frame=lines,
    caption=Arquivo de entrada contendo as vagas de estacionamento,
    label=code:spots,
    frame=shadowbox,
    rulesepcolor=\color{gray},
    xleftmargin=20pt,
    framexleftmargin=15pt,
    keywordstyle=\color{blue}\bf,
    commentstyle=\color{OliveGreen},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    breaklines=true,
    showstringspaces=false,
    basicstyle=\footnotesize,
    emph={uuid,node},emphstyle={\color{magenta}}}
    \lstinputlisting{files/park.xml}

Na Listagem \ref{code:trips} é apresentado um recorte do arquivo de entrada da
simulação contendo as viagens a serem realizadas. Cada linha contendo a tag
\textit{trip} representa a viagem de um ou mais agentes na simulação, apesar do
simulador suportar viagens multimodais, para esse teste utilizamos apenas
viagens de carro. Cada viagem possui uma origem (\textit{origin}) e um destino
(\textit{destination}), sendo esses nós do grafo da infraestrutura rodoviária;
o sentido da rua de partida (\textit{link\_origin}), já que a origem é um nó do
grafo é necessário saber para qual aresta de saída vamos partir; um contador
representando o número de atores que executarão aquela viagem (\textit{count});
e o tempo de simulação que irá iniciar a viagem em segundos (\textit{start}).

\lstset{
    language=xml,
    tabsize=3,
    frame=lines,
    caption=Arquivo de entrada contendo viagens,
    label=code:trips,
    frame=shadowbox,
    rulesepcolor=\color{gray},
    xleftmargin=20pt,
    framexleftmargin=15pt,
    keywordstyle=\color{blue}\bf,
    commentstyle=\color{OliveGreen},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    breaklines=true,
    showstringspaces=false,
    basicstyle=\footnotesize,
    emph={origin,link_origin,destination,count,start},emphstyle={\color{magenta}}}
    \lstinputlisting{files/trips.xml}


Para a realização desse teste inicial da integração foram utilizados dois
computadores pessoais com 8 GB de memória RAM e 4 CPUs, um executando todos os
microserviços da plataforma e outro executando o simulador. O cenário de teste
envolvia 1000 carros se movendo na cidade de São Paulo de 6h até 7h30 da manhã,
sendo que haviam 1600 vagas espalhadas disponíveis. Durante a simulação foi
feito o registro do tempo em que foi feito a requisição para a plataforma, o
tempo em que foi recebida a resposta, e se a mesma obteve sucesso ou não. A
seguir serão apresentados resultados preliminares do teste experimental de
desempenho realizado acerca do tempo de resposta (\textit{response time}) e
vazão (\textit{throughput}) do serviço de descoberta de recursos da plataforma.

A carga realizada pelo simulador na plataforma nesse teste pode ser vista na
Figura \ref{fig:load}, onde podemos ver o número de requisições realizadas por
minuto. Em média, dois segundo de simulação representou um segundo em tempo
real, isso ocorreu pelo fato de não termos muitos carros na simulação e os
\textit{ticks} de simulação ociosos serem executados de maneira mais rápida.
É possível perceber que no início da simulação um número menor de carros
requisitam vagas de estacionamento para a plataforma, já que grande maioria dos
carros ainda estão iniciando ou irão iniciar o seu trajeto. O pico de
requisições acontece próximo dos 37 minutos de teste, aproximadamente as 7h15
da manhã na simulação, onde 81 requisições foram realizadas para a plataforma
no mesmo minuto. Após esse horário de pico a maioria dos carros já estão
chegando aos seus respectivos destinos e o número de requisições é reduzido.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.4\textwidth]{scripts/load.png}
	\caption{Carga realizada na plataforma InterSCity via o simulador
	InterSCSimulator}
	\label{fig:load}
\end{figure}

A Figura \ref{fig:rate} apresenta o número de requisições que foram respondidas
com sucesso ou não pela plataforma durante o teste, sendo considerado sucesso
as requisições que retornaram o código \textit{HTTP} 200 e erro qualquer outro
código de retorno. Um pouco mais de 10\% das requisições foram respondidas sem
sucesso, sendo que esses erros aconteceram devido a \textit{timeouts} do
serviço da plataforma. Acreditamos que isso ocorreu pelo fato da máquina
utilizada para implantação da plataforma possuir poucos recursos
computacionais.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.4\textwidth]{scripts/rate.png}
	\caption{Estado das respostas do serviço de descoberta da plataforma InterSCity}
	\label{fig:rate}
\end{figure}

Na Figura \ref{fig:response_time} temos a média do tempo de resposta do serviço
em questão por minuto. Aproximadamente 76\% das requisições respondidas com
sucesso demoraram até 10 segundos, essas ocorrendo até os 35 minutos de teste
(7h10 da manhã na simulação). Após esse momento, acreditamos que devido a
falta de recursos computacionais e sendo esse o pico de requisições deste
teste (como pode ser visto na Figura \ref{fig:load}), a plataforma começou a
aumentar o seu tempo médio de resposta, em que 6\% dessas respostas demoraram
mais de 50 segundos. 

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.4\textwidth]{scripts/response_time.png}
	\caption{Tempo de resposta do serviço de descoberta da plataforma InterSCity}
	\label{fig:response_time}
\end{figure}

A quantidade de requisições respondidas com sucesso por minuto é apresentada na
Figura \ref{fig:throughput}, representando a vazão do serviço de descoberta.
Podemos notar que a vazão cresce proporcionalmente ao número de requisições
realizadas até por volta dos 38 minutos de teste (7h15 da manhã na simulação).
Assim como o tempo médio de resposta, a vazão do serviço é degradada nesse
pico de requisições. Contudo o número de respostas também é reduzido devido a
chegada do término da simulação.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.4\textwidth]{scripts/throughput.png}
	\caption{Vazão do serviço de descoberta da plataforma InterSCity}
	\label{fig:throughput}
\end{figure}

Consideramos os testes iniciais de desempenho realizados a partir da integração
feita ainda não ideais devido a implantação da plataforma e simulador em
máquinas com poucos recursos computacionais. Por isso não foi possível a
realização de um teste em escala maior, e mesmo assim estressando essa
instância da plataforma. Estamos trabalhando para a realização desse mesmo
teste de desempenho em maior escala (com 467744 vagas e 9329 veículos
realizando trajetos de 6h às 9h da manhã em São Paulo). Para isso estamos
automatizando uma implantação mais realista no \textit{Google Cloud Platform},
utilizando algumas vantagens não exploradas como a escala automática
(\textit{auto-scaling}) dos microserviços da plataforma.

Contudo, a infraestrutura provida pela integração da plataforma InterSCity e o
simulador InterSCSimulator nos permitirá realizar testes de desempenho na
escala da cidade de São Paulo em um cenário realista, mostrando a viabilidade
da proposta trazida para esta pesquisa.
